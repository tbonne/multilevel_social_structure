package multiLevelGroups;

import java.io.BufferedWriter;
import java.io.FileWriter;
import java.util.ArrayList;
import java.util.List;
import java.util.*;

import repast.simphony.engine.environment.RunEnvironment;
import repast.simphony.util.ContextUtils;

public class Observer {
	
	
	//////////
	//
	// Methods to record behaviours
	//
	//////////
	
	//this will export all influence patterns between individuals at the end of the simulation
	public static void recordInfluencePatterns(ArrayList<OMU> agents){

		//get all individuals
		/*Iterable<OMU> allAgents = ModelSetup.getContext().getAgentLayer(OMU.class);
		List<OMU> allAgentsOrdered = new ArrayList<OMU>();

		//place it into a list
		for(OMU omu : allAgents){
			allAgentsOrdered.add(omu);
		}*/

		//double[][] asso = new double[allAgentsOrdered.size()][allAgentsOrdered.size()];
		ArrayList<List<String>> edgeList = new ArrayList<List<String>>();

		//for each agent place associations into a vector and add to a matrix
		for(OMU focal: agents){

			//int myIndex = allAgentsOrdered.indexOf(focal);

			//for all agents see if there is an association
			for(OMU other: agents){

				//int otherIndex = allAgentsOrdered.indexOf(other);

				//yes there is an association
				if(focal.familiarOMUs.contains(other)){

					//int otherIndex_in_focal = focal.familiarOMUs.indexOf(other);
					//asso[myIndex][otherIndex] = focal.familiarOMU_values.get(otherIndex_in_focal);
					
					double weight = focal.familiarOMU_values.get(focal.familiarOMUs.indexOf(other));

					edgeList.add(Arrays.asList(focal.name, other.name, Double.toString(weight) ));

					//no association
					//} else {
					//
					//	asso[myIndex][otherIndex] = 0 ;
					//	
					//}

				}

			}
		}

		//print the influence association matrix
		printArrayToCSV(edgeList);

	}


	
	
	//this will export all influence patterns between individuals at the end of the simulation
	public static void recordSpatialPatterns(ArrayList<OMU> agents){  

		//get all individuals
		/*Iterable<OMU> allAgents = ModelSetup.getContext().getAgentLayer(OMU.class);
		List<OMU> allAgentsOrdered = new ArrayList<OMU>();

		//place it into a list
		for(OMU omu : allAgents){
			allAgentsOrdered.add(omu);
		}*/

		//double[][] asso = new double[allAgentsOrdered.size()][allAgentsOrdered.size()];
		ArrayList<List<String>> edgeList = new ArrayList<List<String>>();

		//for each agent place associations into a vector and add to a matrix
		for(OMU focal: agents){

			//int myIndex = allAgentsOrdered.indexOf(focal);

			//for all the focal agents associations
			for(OMU other: agents){

				//int otherIndex = allAgentsOrdered.indexOf(other);
				double dist = Math.pow(Math.pow(focal.getMyCoord().x - other.getMyCoord().x,2)+Math.pow(focal.getMyCoord().y - other.getMyCoord().y,2),0.5);

				//yes there is an association
				if(dist<30){

					//int otherIndex_in_focal = focal.spatialAssoInds.indexOf(other);
					//asso[myIndex][otherIndex] = focal.spatialAssoVal.get(otherIndex_in_focal);
					edgeList.add(Arrays.asList(focal.name, other.name));

					//no association
					//} else {
					//
					//	asso[myIndex][otherIndex] = 0 ;
					//} 

				}

			}
		}

		//print the spatial association matrix
		printSpatialArrayToCSV(edgeList);

	}

	
	
	//this will export home range sizes of all individuals
	public static void recordHomeRangePatterns(ArrayList<OMU> agents ){  

		//get all individuals
		/*Iterable<OMU> allAgents = ModelSetup.getContext().getAgentLayer(OMU.class);
		List<OMU> allAgentsOrdered = new ArrayList<OMU>();

		//place it into a list
		for(OMU omu : allAgents){
			allAgentsOrdered.add(omu);
		}*/

		double[] hr = new double[ModelSetup.id_count];
		String[] hr_id = new String[ModelSetup.id_count];
		int index_i = 0;

		//for each agent place associations into a vector and add to a matrix
		for(OMU focal: agents){

			hr[index_i] = focal.getHomeRangeSize();
			hr_id[index_i] = focal.name;
			index_i = index_i + 1;
			
			System.out.println("home range size: "+ focal.getHomeRangeSize());
		}

		//print the spatial association matrix
		printCSV_homeRange(hr,hr_id, agents.size());

	}
	
	
	
	//////////
	//
	// Methods for printing to CSV
	//
	//////////
	
	public static void printArrayToCSV(ArrayList<List<String>> edges){

		try
		{
			BufferedWriter writer = new BufferedWriter(new FileWriter("socialStructure_"+Params.socialWeight+"_"+Params.homeWeight+"_"+RunEnvironment.getInstance().getCurrentSchedule().getTickCount()+".csv",false));
			
			//header
			writer.append("from , to, weight, time");
			writer.newLine();

			//for each row and column
			int size = edges.size();
			for(int i = 0; i < size; i++) {
				
				List<String> supp = edges.get(i);
				writer.append(String.valueOf(supp.get(0)));
				writer.append(',');
				writer.append(String.valueOf(supp.get(1)));
				writer.append(',');
				writer.append(String.valueOf(supp.get(2)));
				writer.append(',');
				writer.append( Double.toString(RunEnvironment.getInstance().getCurrentSchedule().getTickCount() ) );
				writer.newLine();
			}
			
			writer.flush();
			writer.close();
		}        
		catch(Exception e)
		{
			e.printStackTrace();
		}

	}

	
	public static void printSpatialArrayToCSV(ArrayList<List<String>> edges){

		try
		{
			BufferedWriter writer = new BufferedWriter(new FileWriter("spatialStructure_"+Params.socialWeight+"_"+Params.homeWeight+"_"+RunEnvironment.getInstance().getCurrentSchedule().getTickCount()+".csv",false));

			//header
			writer.append("from , to, time");
			writer.newLine();
			
			//for each row and column
			int size = edges.size();
			for(int i = 0; i < size; i++) {
				
				List<String> supp = edges.get(i);
				writer.append(String.valueOf(supp.get(0)));
				writer.append(',');
				writer.append(String.valueOf(supp.get(1)));
				writer.append(',');
				writer.append( Double.toString(RunEnvironment.getInstance().getCurrentSchedule().getTickCount() ) );
				writer.newLine();
			}
			
			writer.flush();
			writer.close();
		}        
		catch(Exception e)
		{
			e.printStackTrace();
		}

	}
	
	
	public static void printCSV_homeRange(double[] hr,String[] hr_id, int size){

		try
		{
			BufferedWriter writer = new BufferedWriter(new FileWriter("homeRangeStructure_"+Params.socialWeight+"_"+Params.homeWeight+"_"+RunEnvironment.getInstance().getCurrentSchedule().getTickCount()+".csv",false));

			//for each row and column
			for(int i = 0; i < size; i++) {
					writer.append(String.valueOf(hr[i]));
					writer.append(',');
					writer.append(String.valueOf(hr_id[i]));
					writer.newLine();
					
			}
			
			writer.flush();
			writer.close();
		}        
		catch(Exception e)
		{
			e.printStackTrace();
		}

	}


}
